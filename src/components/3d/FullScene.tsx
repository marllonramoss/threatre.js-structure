'use client';

import { Canvas, useFrame, useThree } from '@react-three/fiber';
import { useGLTF, useAnimations, Environment } from '@react-three/drei';
import { Suspense, useRef, useState, useEffect } from 'react';
import * as THREE from 'three';

import { getProject } from '@theatre/core'
import studio from '@theatre/studio'
// import { editable as e, SheetProvider, PerspectiveCamera } from '@theatre/r3f'
// @ts-ignore
import extension from '@theatre/r3f/dist/extension'

import { SheetProvider, editable as e, PerspectiveCamera } from '@theatre/r3f'

studio.initialize()
studio.extend(extension)

// our Theatre.js project sheet, we'll use this later
const demoSheet = getProject('Demo Project').sheet('Demo Sheet')



/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

export function Model(props: any) {
  const group = useRef<THREE.Group>(null);
  const { nodes, materials, animations } = useGLTF('/3d_models/ADVANCEDPROJECT.glb');
  const { actions } = useAnimations(animations, group);
  const headRef = useRef<THREE.Mesh>(null);
  const absBrainRef = useRef<THREE.Group>(null);
  const [particles, setParticles] = useState<THREE.Points | null>(null);
  const [originalGeometry, setOriginalGeometry] = useState<THREE.BufferGeometry | null>(null);
  
  // Criar partículas e preparar geometria original
  useEffect(() => {
    if (headRef.current && !particles) {
      const head = headRef.current;
      const geometry = head.geometry;
      
      // Guardar geometria original
      setOriginalGeometry(geometry.clone());
      
      // Criar geometria de partículas
      const pointsGeometry = new THREE.BufferGeometry();
      const positions = geometry.attributes.position;
      pointsGeometry.setAttribute('position', positions);
      
      // Criar material para partículas
      const pointsMaterial = new THREE.PointsMaterial({
        size: 0.02,
        color: 0x000000,
        transparent: true,
        opacity: 0.8,
      });
      
      // Criar sistema de partículas
      const points = new THREE.Points(pointsGeometry, pointsMaterial);
      points.position.copy(head.position);
      points.rotation.copy(head.rotation);
      points.scale.copy(head.scale);
      points.visible = true; // Sempre visível
      
      setParticles(points);
      
      // Adicionar partículas à cena
      if (head.parent) {
        head.parent.add(points);
      }
    }
  }, [particles]);
  
  // Efeito de partículas constante + rotação do abs_brain
  useFrame((state) => {
    if (!headRef.current || !particles || !originalGeometry) return;
    
    const head = headRef.current;
    
    // Esconder o mesh original e mostrar partículas
    head.visible = false;
    particles.visible = true;
    
    // Obter posições originais e das partículas
    const originalPositions = originalGeometry.attributes.position.array as Float32Array;
    const particlePositions = particles.geometry.attributes.position.array as Float32Array;
    
    // Aplicar movimento constante a todos os vértices
    for (let i = 0; i < originalPositions.length; i += 3) {
      const vertexIndex = i / 3;
      
      const time = state.clock.elapsedTime;
      const noiseX = Math.sin(time * 0.5 + vertexIndex * 0.1) * 0.05;
      const noiseY = Math.cos(time * 0.4 + vertexIndex * 0.15) * 0.05;
      const noiseZ = Math.sin(time * 0.6 + vertexIndex * 0.12) * 0.03;
      
      // Aplicar movimento às partículas
      particlePositions[i] = originalPositions[i] + noiseX;
      particlePositions[i + 1] = originalPositions[i + 1] + noiseY;
      particlePositions[i + 2] = originalPositions[i + 2] + noiseZ;
    }
    
    // Atualizar geometria das partículas
    particles.geometry.attributes.position.needsUpdate = true;
    
    // Rotação constante e natural do abs_brain
    if (absBrainRef.current) {
      const time = state.clock.elapsedTime;
      const rotationSpeed = 0.3; // Velocidade de rotação
      
      // Rotação suave em Y (eixo vertical)
      absBrainRef.current.rotation.y = time * rotationSpeed;
      
      // Rotação sutil em X para movimento mais orgânico
      absBrainRef.current.rotation.x = Math.sin(time * 0.2) * 0.1;
      
      // Rotação sutil em Z para movimento mais natural
      absBrainRef.current.rotation.z = Math.cos(time * 0.15) * 0.05;
    }
  });
  
  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene">
        <mesh
          ref={headRef}
          name="head"
          castShadow
          receiveShadow
          geometry={(nodes as any).head.geometry}
          material={(materials as any).headMat}
          position={[0, 3.518, 0]}
          rotation={[0, -0.683, 0]}
          scale={2}
        />
        <group
          ref={absBrainRef}
          name="abs_brain"
          position={[0, 5.128, 0]}
          rotation={[-Math.PI / 2, 0, 0]}
          scale={0.005}>
          <group name="44a5e8b8e72c403c900c82951512c998fbx" rotation={[Math.PI / 2, 0, 0]}>
            <group name="RootNode">
              <group name="VoronoiDynoBake" rotation={[-Math.PI / 2, 0, 0]} scale={100}>
                <mesh
                  name="VoronoiDynoBake_Material_0"
                  castShadow
                  receiveShadow
                  geometry={(nodes as any).VoronoiDynoBake_Material_0.geometry}
                  material={(materials as any)['Material.001']}
                  position={[0, 0, -0.299]}
                  scale={2}
                />
              </group>
            </group>
          </group>
        </group>
        <mesh
          name="brain"
          castShadow
          receiveShadow
          geometry={(nodes as any).brain.geometry}
          material={(nodes as any).brain.material}
          position={[0, 5.329, 0]}
          scale={1.3}
        />
        <group name="Armature_1">
          <skinnedMesh
            name="arm_1"
            geometry={(nodes as any).arm_1.geometry}
            material={(materials as any).headMat}
            skeleton={(nodes as any).arm_1.skeleton}
          />
          <primitive object={(nodes as any).Bone} />
          <primitive object={(nodes as any).Bone024} />
          <primitive object={(nodes as any).Bone027} />
        </group>
        <group name="Armature_2" position={[0.025, 2.1, -0.007]} rotation={[3.127, 0.04, 0.024]}>
          <skinnedMesh
            name="arm_2"
            geometry={(nodes as any).arm_2.geometry}
            material={(materials as any).headMat}
            skeleton={(nodes as any).arm_2.skeleton}
          />
          <primitive object={(nodes as any).Bone_1} />
        </group>
        <group name="Armature_3" position={[-0.015, 2.1, 0.004]} rotation={[0, 0, -3.135]}>
          <skinnedMesh
            name="arm_3"
            geometry={(nodes as any).arm_3.geometry}
            material={(materials as any).headMat}
            skeleton={(nodes as any).arm_3.skeleton}
          />
          <primitive object={(nodes as any).Bone_2} />
        </group>
        <mesh
          name="BézierCurve"
          castShadow
          receiveShadow
          geometry={(nodes as any).BézierCurve.geometry}
          material={(materials as any).headMat}
          position={[-0.098, 4.54, -0.145]}
          rotation={[2.761, -1.281, 1.164]}
          scale={[0.827, 1.32, 1.083]}
        />
        <mesh
          name="Text"
          castShadow
          receiveShadow
          geometry={(nodes as any).Text.geometry}
          material={(materials as any)['Material.002']}
          position={[4.53, 9.399, -13.131]}
          rotation={[1.556, -0.02, 0.937]}
          scale={0.593}
        />
        <mesh
          name="brain2"
          castShadow
          receiveShadow
          geometry={(nodes as any).brain2.geometry}
          material={(materials as any).headMat}
          position={[0.036, 5.339, -0.035]}
          scale={0.6}
        />
        <mesh
          name="up_light"
          castShadow
          receiveShadow
          geometry={(nodes as any).up_light.geometry}
          material={(materials as any).Material}
          position={[0.001, 10.265, 0.001]}
          scale={[4.503, 1.247, 5.821]}
        />
        <mesh
          name="head2"
          castShadow
          receiveShadow
          geometry={(nodes as any).head2.geometry}
          position={[0, 3.518, 0]}
          rotation={[0, -0.683, 0]}
          scale={1.9}
        >
          <meshPhysicalMaterial
            color="white"
            transparent={true}
            opacity={0.3}
            transmission={0.8}
            thickness={0.8}
            roughness={0.05}
            metalness={0.0}
            clearcoat={1.0}
            clearcoatRoughness={0.05}
            ior={1.52}
            attenuationDistance={0.5}
            attenuationColor="#ffffff"
            envMapIntensity={1.0}
            reflectivity={1.0}
          />
        </mesh>
      </group>
    </group>
  );
}

// Função para renderizar a cena completa
function Scene() {
  return (
    <>
      {/* Ambiente com HDR para iluminação realista */}
      <Environment 
        preset="sunset"
        background={false}
        blur={0.8}
      />
      
      {/* Iluminação ambiente principal */}
      <ambientLight intensity={1.2} color="#ffffff" />
      
      {/* Luz direcional principal - Sol */}
      <directionalLight 
        position={[15, 20, 10]} 
        intensity={2.5}
        color="#ffffff"
        castShadow
        shadow-mapSize-width={2048}
        shadow-mapSize-height={2048}
        shadow-camera-far={50}
        shadow-camera-left={-20}
        shadow-camera-right={20}
        shadow-camera-top={20}
        shadow-camera-bottom={-20}
      />
      
      {/* Luz direcional secundária - Preenchimento */}
      <directionalLight 
        position={[-10, 15, -5]} 
        intensity={1.8}
        color="#f0f8ff"
        castShadow
      />
      
      {/* Luz pontual frontal - Spotlight */}
      <pointLight 
        position={[0, 8, 15]} 
        intensity={3.0}
        color="#ffffff"
        distance={30}
        decay={1}
        castShadow
      />
      
      {/* Luz pontual traseira - Backlight */}
      <pointLight  
        position={[0, 5, -15]} 
        intensity={2.0}
        color="#e6f3ff"
        distance={25}
        decay={1}
        castShadow
      />
      
      {/* Luz hemisférica para iluminação suave */}
      <hemisphereLight 
        intensity={1.0}
        color="#ffffff"
        groundColor="#e6f3ff"
      />
      
      {/* Modelo ADVANCEDPROJECT */}
      <Model 
        scale={0.5}
        position={[0, 0.1, 0]}
        rotation={[0, 0, 0]}
      />
    </>
  );
}

export default function MainCanvas1() {
  return (
    <div className="absolute top-0 left-0 w-full h-[200vh] pointer-events-none z-[1]">
      <Canvas
        gl={{ 
          antialias: true,
          alpha: true,
          powerPreference: "high-performance"
        }}
        shadows={{
          enabled: true,
          autoUpdate: true,
          type: THREE.PCFSoftShadowMap
        }}
        style={{ pointerEvents: 'none' }}
      >
         <SheetProvider sheet={demoSheet}>
          <PerspectiveCamera
            theatreKey="Camera"
            makeDefault
            position={[0, 0, 8]}
            fov={50}
          />
          <Suspense fallback={null}>
            <Scene />
          </Suspense>
        </SheetProvider>

      </Canvas>
    </div>
  );
}

// Pré-carregar o modelo
useGLTF.preload('/3d_models/ADVANCEDPROJECT.glb');
